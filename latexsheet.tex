\documentclass[10pt,landscape]{article}
\usepackage{multicol}
\usepackage{calc}
\usepackage{ifthen}
\usepackage[a4paper, portrait]{geometry}
\usepackage{hyperref}

\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{listings}
\lstset{
    basicstyle=\ttfamily,
    breaklines=true,
    prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    tabsize=2,
    gobble=8,
    frame=single,
    literate={\ \ }{{\ }}1
}

% This sets page margins to .5 inch if using letter paper, and to 1cm
% if using A4 paper. (This probably isn't strictly necessary.)
% If using another size paper, use default 1cm margins.
\ifthenelse{\lengthtest { \paperwidth = 11in}}
{ \geometry{top=.5in,left=.5in,right=.5in,bottom=.5in} }
{\ifthenelse{ \lengthtest{ \paperwidth = 297mm}}
{\geometry{top=0.25cm,left=0.25cm,right=0.25cm,bottom=0.25cm} }
{\geometry{top=0.25cm,left=0.25cm,right=0.25cm,bottom=0.25cm} }
}

% Turn off header and footer
\pagestyle{empty}


% Redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
{-1ex plus -.5ex minus -.2ex}%
{0.5ex plus .2ex}%x
{\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
{-1explus -.5ex minus -.2ex}%
{0.5ex plus .2ex}%
{\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
{-1ex plus -.5ex minus -.2ex}%
{1ex plus .2ex}%
{\normalfont\small\bfseries}}
\makeatother

% Define BibTeX command
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

% Don't print section numbers
\setcounter{secnumdepth}{0}


\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}


% -----------------------------------------------------------------------

\begin{document}

    \raggedright
    \footnotesize
    \begin{multicols}{2}


% multicol parameters
% These lengths are set only within the two main columns
%\setlength{\columnseprule}{0.25pt}
        \setlength{\premulticols}{1pt}
        \setlength{\postmulticols}{1pt}
        \setlength{\multicolsep}{1pt}
        \setlength{\columnsep}{2pt}

        \begin{center}
            \Large{\textbf{WED3 Summary}} \\
        \end{center}


        \section{SPA-Überblick}

        \textbf{Historisch}: 1990 nur statische Seiten, ab 1995 wenig JavaScript in Seiten.
        2005 Erfindung von Asynchronous JavaScript and XML, 2014 Release von HTML spezifisch for SPA.
        2015 Google pusht PWA (Benachrichtungen, Service Workers, Web App Manifests).

        Browser werden immer mächtiger: Kamera-Zugriff, Bluetooth, Gaming Devices etc. können angesteuert werden.
        Browser ist ein Meta Layer (eigentliche Idee hinter Java).

        Browser-basierte Applikationen funktionieren von überall her, jederzeit.
        Ermöglicht SaaS, keine Software-Updates nötig, können verpackt werden für Clients (Electron) oder Apps (NativeScript).

        Nachteile: Kein direkter Hardware-Zugriff, Applikationen tendenziell ineffizienter, komplexere Deployment-Strategien.

        Traditionelle Architektur: Jeder Aufruf rendert eine neue Seite in HTML.
        SPA: Interaktion über Anpassung des DOMs, Server bietet APIs (mehr Logik im Client).

        Charakter von SPAs: Nur HTML5 / CSS / JS, keine Page Reloads, funktionierender Zurück-Button, Lesezeichen funktionieren, limitierte Offline-Funktionalitäten.

        \includegraphics[width=\linewidth]{spa_logical_overview}

        \textbf{Bundeling}: Gesamter JavaScript-Code muss über tendenziell langsame Leitung zu Kunden, bundling und minifying reduziert Grösse, grosse SPAs brauchen vernünftiges Dependency Management, Module können auch On-Demand geladen werden, Bundler kommen und gehen (z.B. Webpack, Grunt, Rollup, esbuild)
        Webpack:

        \begin{itemize}
            \item Entry: Startpunkt wo Webpack mit Bundling beginnt und Dependencies findet.
            \item Output: Wo sollen die finalen Dateien hingeschrieben werden?
            \item Loaders: Transformiert Dateien in Module.
            \item Plugins: Können zusätzliche Funktionalitäten bieten (z.B. Asset Management)
            \item Mode: Aktivierung bestimmter Optimierungstechniken nach Bedarf.
        \end{itemize}

        \textbf{Routing}: Wird in SPAs komplett client-seitig gemacht, Browser "fakt" URL-Änderungen, Content muss für Zurück-Button persistiert werden.
        Früher gelöst mittels \#, heute mit \lstinline{window.history} / \lstinline{window.history.pushState}, verhindert das der Browser die URL wirklich lädt.
        Meistens gelöst über eine Routing-Tabelle, welche je nach verlangter Route eine andere Funktion aufruft.

        \textbf{Dependency Injection}: Reduziert Kopplung zwischen Konsument und Implementation, "Verträge" zwischen Klassen basieren auf Interfaces, erlaubt flexible Ersetzung einer konkreten Implementieren.


        \section{React}

        Eine Bibliothek, kein Framework!
        Umfasst nur das V aus MVC.
        \textbf{Prinzip von React}: Komplexe Probleme in kleinere Komponenten aufteilen.
        Verbessert Wiederverwendbarkeit, Erweiterbarkeit, Wartbarkeit, Testbarkeit, Aufgabenverteilung im Team.

        \textbf{JSX}: React-Komponenten sind Funktionen, welche HTML zurückgeben können (JSX).
        JSX kann an beliebigen Stellen verwendet werden, wenn Dateiendung stimmt.
        In eckigen Klammern stehen dann JavaScript-Expresssions.
        Einschränkung: React-Elemente müssen mit Grossbuchstaben starten, \lstinline{className} anstatt \lstinline{class} verwenden wegen gesperrter Keywords.
        Unterelement sind mittels \lstinline{props.children} zugänglich.
        \lstinline{props} als read-only behandeln!

        \begin{lstlisting}
        function Container(props) {
            return (
            <div className="container">
                {props.children}</div>
            )
        }

        function App() {
            return (
                <Container><HelloMessage name="OST"/></Container>
            )
        }
        \end{lstlisting}

        Styles werden als Objekt übergeben, muss Camel Case verwenden (\lstinline{min-height} wird zu \lstinline{minHeight}).
        Die JSX-Elemente werden zu \lstinline{React.createElement} umgewandelt, daher muss in jedem JSX-File React importiert werden, auch wenn es nicht aktiv verwendet wird.

        \begin{lstlisting}
        function Container(props) {
          return React.createElement("div",
            { className: "container" },
            props.children
          )
        }
        \end{lstlisting}

        React-Kompontenten konnten früher mittels Klasse definiert werden.
        Seit den Hooks aber nicht mehr nötig.

        \begin{lstlisting}
        class HelloMessage extends React.Component {
          render() {
            return <div>Hello {this.props.name}</div>
          }
        }
        \end{lstlisting}

        Anlegen einer neuen App: \lstinline{npx create-react-app hello-ost}.
        Konfiguration kommt dann aus einem NPM-Paket (Webpack, Babel, etc.).
        Kann mittels \lstinline{eject} entfernt werden.

        \textbf{Mount}: Komponenten müssen mittels Instruktion gemountet werden.
        Theoretisch mehrere Mounts pro Webseite möglich.

        \begin{lstlisting}
        import React from 'react';
        import ReactDOM from 'react-dom/client';
        import App from './App';

        const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
        \end{lstlisting}

        \textbf{State}: Mittels \lstinline{useState} Hook.
        \lstinline{useState} müssen immer in derselben Reihenfolge erfolgen, somit if-Konditionen nicht möglich.
        State einer Komponente ist immer privat, kann aber als Props weitergegeben werden.
        Auch Event-Handler / Setter können als Props an Komponenten weiter gegeben werden.
        Zustand darf ausschliesslich mit Settern geändert werden.

        \begin{lstlisting}
        import { useState } from 'react';

        function Counter() {
          const [counter, setCounter] = useState(0);
          const increment = () => setCounter(counter + 1);
          return (
            <div>
              <p>{counter}</p>
              <button onClick={increment}>Increment Counter</button> </div>
          )
        }
        \end{lstlisting}

        \textbf{Reconciliation}: React-Komponenten werden als virtueller DOM gerendert, Wird der State geändert, erstellt React einen neuen virtuellen DOM, alter und neuer DOM werden verglichen, erst dann werden geänderte DOM-Knoten im Browser erstellt.

        \textbf{Formulare}: Event Handler bei den Inputs registrieren und Zustand ändern.

        \begin{lstlisting}
        <input value={username} type="text" onChange={e => setUsername(e.target.value)} />
        \end{lstlisting}

        Oder mittels \lstinline{onSubmit} auf dem Formular abfangen.

        \begin{lstlisting}
        function handleSubmit(event) {
            event.preventDefault();
            alert("Username: " + username + ", Password: " + password)
        }
        \end{lstlisting}

        \textbf{Styling}: Meistens mittels Widget-Library, z.B. Reactstrap, Material UI oder Semantic.

        \textbf{Lifecycles}: Klassenkomponenten haben eine Reihe an Lifecycle-Methoden wie \lstinline{componentDidMount} , \lstinline{shouldComponentUpdate(nextProps, nextState)} oder \lstinline{componentWillUnmount}.
        Mit Hooks vereinfacht mit \lstinline{useEffect}.
        \lstinline{useEffect} kann mit Promises verwendet werden.

        \begin{lstlisting}
        useEffect(() => {
          const timerID = setInterval(() => setDate(new Date()), 1000) // ausgefuehrt beim Mount
          return () => {
            clearInterval(timerID) // ausgefuehrt beim Unmount
          }
        }, []) // Arrays von Dependencies, kann genutzt werden, um Effekt auszuloesen, wenn sich Abhaengigkeit aendert
        \end{lstlisting}

        \textbf{Routing}: Mittels React Router (Kollektion von Navigationskomponenten für React, für Web und Native).
        Alle Router müssen Teil von \lstinline{<BrowserRouter>} sein.
        \lstinline[mathescape]!<Route path="/about" element ={<About/>} />!: Component About wird nur gerendert, wenn der path matcht.
        App-interne Links verwenden nicht <a> sondern <Link>. \lstinline[mathescape]!<Link to="/about">About</Link>!

        \textbf{Type-Checking}: Flow erweitert JavaScript um Typannotationen.
        Lieber Typescript für mehr Typsicherheit in React-Komponenten.
        Flow sind nur Annotations, können daher einfach ignoriert werden, Typescript ist eine ganze Programmiersprache.

        \textbf{React Context}: Daten immer als Props mitgeben ist mühsam, Zustand verteilt sich über gesamte Applikation, Calls sind auch verteilt.
        React Context ermöglicht es, Props für alle Unterkomponenten zur Verfügung zu stellen.

        \begin{lstlisting}
        const ThemeContext = React.createContext(themes.light);

        function App() {
          return (
            <ThemeContext.Provider
              value={themes.dark}>
              <Toolbar />
            </ThemeContext.Provider>
          );
        }

        function ThemedButton() {
          const theme = useContext(ThemeContext);
          return (
            <button style={{
              background: theme.background,
              color: theme.foreground
            }}>
              {" "}I am styled by theme context!{" "}
            </button>
          );
        }
        \end{lstlisting}

        \textbf{Redux}: Darstellung des States als Baum, Baum ist nicht veränderbar, Veränderungen am Baum führen zu einem neuen Baum, Verwaltung über Stores.

        \includegraphics[width=\linewidth]{redux_data_flow}

        Eine Veränderung braucht eine Action (sehr simple Objekte wie \lstinline!{ type: 'TRANSFER', amount: 100 }!).
        Der Store braucht einen Reducer, um mit der Action den neuen Baum zu machen.
        Reducer sind pure Funktionen ohne Seiteneffekte.

        Soll / Muss in jeder React-Applikation Redux eingesetzt werden?
        Nein, wenn kaum Zustand existiert, der von mehreren Komponenten verwendet wird, lohnt sich der Redux-Overhead nicht.

        \begin{lstlisting}
        function balance(state = 0, action) {
          switch (action.type) {
            case 'TRANSFER':
              return (
                state + action.amount
              )
            default:
              return state
          }
        }
        \end{lstlisting}

        Mehrere Reducer bilden einen Root Reducer.
        Initialer State für die App ist ein leeres Objekt.

        \begin{lstlisting}
        function rootReducer(state = {}, action) {
          return {
            balance: balance(state.balance, action),
            transactions: transactions(state.transactions, action)
          }
        }

        // gleichwertig
        const rootReducer = combineReducers({
           balance,
           transactions
        })

        const store = createStore(rootReducer);
        \end{lstlisting}

        Über Änderungen am State kann man sich mittels Listener benachrichtigen lassen: \lstinline{store.subscribe(() => console.log(store.getState()));}

        \textbf{React und Redux}: Redux Toolkit verwenden.
        \lstinline{createSlice} erstellt neue Stateobjekte, Reduce-Funktionen und Aktionen.
        Action-Type im unteren Beispiel ist \lstinline{balance/transfer}.
        Mittels immer.js scheinbare, direkte Änderungen am State möglich.

        \begin{lstlisting}
        const balanceSlice = createSlice({
          name: "balance",
          initialState: { value: 0 },
          reducers: {
            transfer: (state, action) => {
              state.value += action.payload.amount;
            },
          },
        });
        export const { transfer } = balanceSlice.actions;
        \end{lstlisting}

        \lstinline{configureStore} initialisiert den Redux Store mit den angegeben Reducern.
        Enthält \lstinline{redux-thunk}.
        Redux Thunk erlaubt es uns, anstelle eines Objektes eine Funktion zu dispatchen.

        \begin{lstlisting}
        const store = configureStore({
          reducer: { balance: balanceReducer }
        });
        \end{lstlisting}

        Verfügbarkeit in React-Applikation mittels Provider.

        \begin{lstlisting}
        render(
          <Provider store={store}>
            <App />
          </Provider>,
          document.getElementById('root')
        )
        \end{lstlisting}

        \lstinline{useDispatch} wird für den Dispatch der Aktionen an den Store benutzt.
        \lstinline{useSelector} wird für die Abfrage des States benutzt.

        \begin{lstlisting}
        const dispatch = useDispatch()
        dispatch(transfer({ amount: 10 }))
        const balance = useSelector(state => state.balance.value);
        \end{lstlisting}

        Asynchrone Actions:

        \begin{lstlisting}[belowskip=-0.8 \baselineskip]
        // First, create the thunk
        export const transferAsync = createAsyncThunk(
          "balance/transferApiRequest",
          async (amount) => {
            const response = await api.transfer(amount);
            return response.data;
          }
        );

        const balanceSlice = createSlice({
          initialState: { value: 0, status: "idle" },
          extraReducers: (builder) => {
            builder
              .addCase(transferAsync.pending, (state) => {
                state.status = "loading";
              })
              .addCase(transferAsync.fulfilled, (state, action) => {
                state.status = "idle";
                state.value += action.payload.amount;
              });
          },
        });
        \end{lstlisting}

        \textbf{JHipster}: Fullstack App-Generator mit Angular, React-Redux oder Vue, Spring Boot, Maven/Gradle, NPM, Postgres, MongoDB, Elasticsearch, Cassandra, Kafka etc.
        Bieten eigene DSL für Entities und Relationen.

        \textbf{Testing}: Jest offizielle Lösung von Facebook, kommt mit \lstinline{create-react-app} mit.
        Die React Testing Library baut auf der DOM Testing Library auf und fügt APIs für die Arbeit mit React-Komponenten hinzu.
        JHipster generiert End-to-End-Tests mit Cypress.

        \begin{lstlisting}
        import { render, screen } from '@testing-library/react'
        import userEvent from '@testing-library/user-event'

        test('loads and displays greeting', async () => {
          // ARRANGE
          render(<Fetch url="/greeting" />)

          // ACT
          await userEvent.click(screen.getByText('Load Greeting'))
          await screen.findByRole('heading')

          // ASSERT
          expect(screen.getByRole('heading')).toHaveTextContent('hello there')
          expect(screen.getByRole('button')).toBeDisabled()
        })
        \end{lstlisting}


        \section{Angular}

        \includegraphics[width=\linewidth]{base_angular}

        TypeScript-basiert, mit Dependency Injection, 2-Way-Bindings, klar strukturiert.
        Sollte verwendet werden für lang lebende und komplexe Applikationen.
        Historie: Modernes Angular seit v2, v1 wird AngularJS genannt, keine Gemeinsamkeiten.
        v3 ausgelassen, um Paketnamen zu harmonisieren.
        \lstinline{npx ng new my-app} legt neue Applikation an (Paket lokal installieren mit \lstinline{npm install @angular/cli})

        \includegraphics[width=\linewidth]{angular_logical_layers}

        \textbf{Dependency Injection}: Registration beim Container, Request, Resolve durch Container, Fullfill (TypeScript module/s).
        \textbf{ngModules}: Ein zusammenhängender Codeblock, der eng miteinander verbundenen Fähigkeiten gewidmet ist (TypeScript class).
        Jede App hat mindestens ein Modul, das Root-Modul.
        Exportieren Features wie Services oder Direktive für andere Module.
        ngModule-Deklaration selbst wird in ein TypeScript-Modul eingefügt (meistens über \lstinline{index.ts}).

        \begin{lstlisting}
        @NgModule({
            exports: [] // The subset of declarations that should be visible and usable in the component templates of other modules.
            imports: [CommonModule], // Specifies the modules which exports/providers should be imported into this module.
            declarations: [], // The view classes that belong to this module (components, directives and pipes).
            providers: [], // Creators of services that this module contributes to the global collection of services (Dependency Injection Container); they become accessible in all parts of the app.
            bootstrap: [] // The main application view, called the root component. Only the root module should set this property.
        })

        export class CoreModule { }
        \end{lstlisting}

        \textbf{Module-Importe}: Standardmässig wird alles aus dem Modul importiert und Dependency-injected.
        \lstinline{forChild(config?)}: Statische Methode auf dem Modul, erlaubt Services für den aktuellen Modul-Level zu konfigurieren.
        \lstinline{forRoot(config?)}: Statische Methode auf dem Modul, injected und konfiguriert Services global.
        Nur im Root-Modul machen!
        \lstinline{providedIn: 'root'} bevorzugen, wenn Services keine Konfiguration benötigen.

        \includegraphics[width=\linewidth]{angular_module_big_picture}

        \textbf{Modultypen}: Root / App Modul: Einstiegspunkt in die Applikation.
        Exportiert nichts.
        Konventionell AppModule genannt und existiert in einer Datei namens app.module.ts.
        Importiert BrowserModule, die jede Browser-Anwendung importieren muss

        \textbf{Feature-Modul}: Teile der Applikation.
        Es ist die beste Praxis, Feature-Module in Domain-, Routing-, Service-, Widget- und Lazy-Module aufzuteilen (siehe unten).
        Ermöglicht die Zuweisung von Entwicklungsaufgaben an verschiedene Teams.

        \textbf{Shared-Modul}: "Toolkit" der Applikation, alles was irgendwie in kein Modul passt.
        Keine app-weiten Singleton-Anbieter (Dienste) in einem gemeinsamen Modul angeben.

        \textbf{Core-Modul}: Initialisiert globale Services.
        Ein "lazy-loaded"-Modul, das dieses gemeinsame Modul importiert, erstellt seine eigene Kopie des Dienstes.
        Wird nur vom Root-Modul importiert, der Import in ein anderes Modul, insbesondere in ein "Lazy-Load"-Modul, widerspricht der Absicht und kann zu einem Laufzeitfehler führen.

        \textbf{Lazy Modules}: Ähnlich wie Feature-Modules, werden aber lazy loadet wenn angefragt mittels Dependency Injection.

        \textbf{Feature-Modul-Untertypen}: Domain-Modul: Bereitstellung einer auf einen bestimmten Anwendungsbereich zugeschnittenen Benutzeroberfläche.
        Routing-Modul: Gibt die Routing-spezifischen Konfigurationseinstellungen des Feature- (oder Root-) Moduls an.
        Service-Modul: Bietet Versorgungsdienste wie Datenzugriff und Nachrichtenübermittlung.
        Widget Modul: Macht Komponenten, Direktiven und Pipes für externe Module verfügbar.

        \textbf{Directives}: Enthält Anweisungen zur Transformation des DOM (TypeScript class).
        Besitzen kein Template.
        Brauchen \lstinline{@Directive()}-Decorator.
        Structural directives: Verändern DOM.
        Diese werden im Hintergrund zu \lstinline{<ng-template>} umgewandelt.
        \lstinline{<ng-template>} kann auch verwendet werden, wenn kein HTML-Element benötigt wird.
        \lstinline{<ng-template>} können nicht mit weiteren Structural directives verwendet werden.
        Attribute directives: Ändern des Aussehens oder Verhaltens eines vorhandenen Elements.

        \begin{lstlisting}
        <div *ngIf="hasTitle"><!-- shown if title available --></div>
        <div [ngStyle]="{ 'font-size': isSpecial ? 'x-large' : 'smaller' }">
                 <!-- render element -->
        </div>
        \end{lstlisting}

        \textbf{Template Reference Variables}: Verfügbar im gesamten Template.

        \begin{lstlisting}
        <input placeholder="phone number" #phone>
        <button (click)="callPhone(phone.value)">Call</button>
        \end{lstlisting}

        \textbf{Components}: Eine Komponente ist eine Richtlinie mit einer Vorlage; sie steuert einen Abschnitt der Ansicht (HTML File / (S)CSS / \ldots).
        Basiert auf MVC oder MVVM.
        Eine Komponente sollte so klein und zusammenhängend wie möglich implementiert werden, um die Testbarkeit / Wartbarkeit / Wiederverwendbarkeit zu unterstützen.
        Komponenten kontrollieren die View (genau eine View pro Komponente).
        Mittels Selektor kann Komponent in anderen Views verwendet werden (entweder tag-name oder CSS-Selektor ( id-selector \#topHeader)), braucht Registierung im ngModule bei \lstinline{declarations} und \lstinline{exports}.
        Lifecycle wird verwaltet von Angular (Hydration, Update, Dehydration), können mittels Methoden wie \lstinline{ngOnInit} und \lstinline{ngOnDestroy} erweitert werden.
        Komponent braucht Deklaration wie \lstinline{implements OnInit, OnDestroy}, damit Methoden verwendet werden können.
        View-Code muss gültiges HTML5 sein.

        \begin{lstlisting}
        <p>Your team is <strong>{{counter.team}}</strong></p>
        <p>Your current count is
            <strong>{{counter.count}}</strong>
        </p>
        <form>
            <button (click)="up($event)">Count Up</button>
        </form>

        @Component(...)
        export class CounterComponent implements OnInit {
            counter: CounterModel = new CounterModel(); up(event: UIEvent): void {
                this.counter.count++;
                event.preventDefault();
            }
        }
        \end{lstlisting}

        \textbf{Bindings}: Two Way Binding / Banana in a box [( ... )].
        One Way (from View to Model / Event Binding) ( ... ).
        One Way (from Model to View / Property Binding) [ ... ] or {{ ... }}.

        \begin{lstlisting}
        public counter: any = {
            get team() { return null }, set team(val) { }, eventHandler: () => { }
        }

        <input type="text" [(ngModel)]="counter.team">
        <button (click)="counter.eventHandler($event)">
        <p>... {{counter.team}} ..</p>
        \end{lstlisting}

        Die Bindung an Ziele muss als Inputs oder Outputs deklariert werden.

        \begin{lstlisting}
        @Component({...})
        export class NavigationComponent {
            @Output() click = new EventEmitter<any>();
            @Input() title: string;
        }

        <wed-navigation(click)="..."[title]="..."></wed-...>
        \end{lstlisting}

        \textbf{Metadata}: Metadaten beschreiben eine Klasse und sagen Angular, wie sie zu verarbeiten ist (TypeScript decorator).

        \textbf{Services}: Bietet Logik für jeden Wert, jede Funktion oder jedes Merkmal, das Ihre Anwendung benötigt (TypeScript class).
        Werden mittels Dependency Injection erstellt, wenn Komponenten Service-Abhängigkeit deklarieren.
        \textbf{Service-Kommunikation mit UI}: Theoretisch alles mittels RxJS möglich, in WED3 aber mit \lstinline{EventEmitter} behandelt (siehe oben).
        RxJS implementiert das Observer-Pattern für JavaScript.
        \textbf{Hot Observables}: Sequenz von Events wie Mausklicks, verfügbar für alle Subscriber.
        \textbf{Cold Observables}: Starten erst bei ersten Subscriber, schliessen sobald Task beendet.
        \textbf{Data Resources}: Abstrahieren HTTP-Kommunikation, um Daten abzuholen.
        Jeweils \lstinline{HttpClient} verwenden, verwendet Cold Observerables.

        \begin{lstlisting}
        export class SampleModel { }

        @Injectable({ providedIn: 'root')
        export class SampleService {
            private samples: SampleModel[] = []; // simple cache
            public sampleChanged: EventEmitter<SampleModel[]> = new EventEmitter<SampleModel[]>();
            constructor(
                private dataResource: SampleDataResourceService) {
            }
            load(): void {
                this.dataResource.get().subscribe(
                    (samples: SampleModel[]) => { // update cache, emit change event, ...
                        this.samples = samples;
                        this.sampleChanged.emit(this.samples);
                    });
            }
        }

        @Component({ ... })
        export class SampleComponent implements OnInit, OnDestroy {
            private samples: SampleModel[];
            private samplesSubscription: Subscription;
            constructor(private sampleService: SampleService) { }

            ngOnInit() {
                this.samplesSubscription = this.sampleService.samplesChanged.subscribe(
                    (data: SampleModel[]) => { this.samples = data; });
            }

            ngOnDestroy() {
                this.samplesSubscription.unsubscribe();
            }
        }
        \end{lstlisting}

        HTTP-Requests können abgefangen und modifiziert werden.

        \begin{lstlisting}
            @NgModule({ ...})
            export class SampleModule {
                static forRoot(config?: {}): ModuleWithProviders {
                    return {
                        ngModule: SampleModule,
                        providers: [
                            {
                                provide: HTTP_INTERCEPTOR,
                                useClass: AuthInterceptor,
                                multi: true
                            }
                        ]
                    }
                }
            }

            @Injectable()
            export class AuthInterceptor implements HttpInterceptor {
                constructor(private store: SecurityTokenStore) { }

                public intercept(req: HttpRequest<any>, next: HttpHandler) {
                    const authReq = req.clone({
                        setHeaders: {
                            Authorization: `Bearer ${this.store.token}`
                        },
                        withCredentials: true
                    });

                    return next.handle(authReq);
                }
            }
        \end{lstlisting}

        \textbf{Template-driven forms}: Angular Template-Syntax mit den formularspezifischen Direktiven und Techniken.
        Erzeugt weniger Code, platziert aber die Validierungslogik in HTML.
        \textbf{Reactive (or model-driven) forms}: Import von \lstinline{ReactiveFormsModule} nötig, Form und Validations werden im Controller gebaut, mehrere asynchrone Validierungen möglich.
        Nicht Teil der Lektüre!

        \begin{lstlisting}
        <form (ngSubmit)="doLogin(sampleForm)" #sampleForm="ngForm">
            <input type="text" class="form-control" id="name" required [(ngModel)]="model.name" name="name" #nameField="ngModel">
            <div [hidden]="nameField.valid || nameField.pristine" class="alert alert-danger">
                Name is required
            </div>

            <button type="submit" class="btn btn-success" [disabled]="!sampleForm.form.valid">Submit</button>
        </form>

        @Component({ ... })
        export class SampleComponent {
            public doLogin(f?: NgForm): boolean {
                if (f?.form.valid) { // store data
                    Component
                    return false; // avoid postback }
                }
            }
        }
        \end{lstlisting}

        \textbf{Component Transclusion / Content Projection}: Selbiges wie Reacts \lstinline{props.children}.

        \begin{lstlisting}[belowskip=-0.8 \baselineskip]
        <wed-navigation>
            <h1 wed-title>WED3 Lecture</h1>
            <menu><!-- ... --></menu>
        </wed-navigation>

        <header>
            <ng-content select='[wed-title]'> </ng-content>
        </header>
        <nav>
            <ng-content select='menu'>
            </ng-content>
        </nav>

        <wed-navigation>
            <header>
                <h1 wed-title>WED3 Lecture</h1>
            </header>
            <nav>
                <menu><!-- ... --></menu>
            </nav>
        </wed-navigation>
        \end{lstlisting}

        \begin{lstlisting}[belowskip=-0.8 \baselineskip]
        var subscription = this.http.get('api/samples').subscribe(
            function (x) { /* onNext: data received (in x) */ },
            function (e) { /* onError: the error (e) has been thrown */ },
            function () { /* onCompleted: the stream is closing down */ }
        );
        \end{lstlisting}

        \textbf{Routing}: Routing Table mappt Routen zu Kompontenten.
        Oberste Routen registrieren mit \lstinline{forRoot()}, Subroutes mit \lstinline{forChild()}.
        \lstinline{forRoot()} kennt auch Router-Service, welcher Singleton ist in Applikation.
        Benötigt \lstinline{<base href="/">} im Header für relative URL oder \lstinline{APP_BASE_HREF} Variable.
        \lstinline{<router-outlet>} definiert, wo Routen angezeigt werden.
        \lstinline{'hero/:id'} ID ist hier eine Variable.
        \lstinline{redirectTo} erlaubt Weiterleitung.
        \lstinline{'**'} ist die Wild-Card-Route für 404.
        Routen werden aufgelöst nach "first come first served".
        Verschachtelung möglich mittels \lstinline{children}, Parent benötigt dann weiteres Router Outlet.

        \begin{lstlisting}
         const appRoutes: Routes = [
            {
                path: '', component: WelcomeComponent,
                children: [
                    { path: ':id', component: SamplesDetailComponent },
                ]
            },
            {
                path: 'config',
                loadChildren: () => import('./cfg/cfg.module').then(m => m.CfgModule), canLoad: [AuthGuard]
            }
        ];

         @NgModule({
            imports: [ RouterModule.forRoot(appRoutes) ],
            exports: [ RouterModule ]
         })
         export class AppRoutingModule {}
         \end{lstlisting}

        \includegraphics[width=\linewidth]{angular_routing}

        \textbf{Angular-Architekturen}: Flow architekturmässig dasselbe wie Redux.
        Redux-Anbindung mittels \lstinline{ngxs} oder \lstinline{ngrx}.

        \includegraphics[width=\linewidth]{angular_architecture_big_picture}

        Vorteile ngrx: Einfaches Debugging, Undo/Redo einfache Implementation, weniger Code in Komponenten, weniger Change Detection Overhead.
        Nachteile: Komplexere Architektur, Datenlogik fragmentiert in Reducer / Effects, zusätzliche Bibliothek.

        \includegraphics[width=\linewidth]{angular_ngrx_architecture}

        \textbf{MVC+S}: Daten-basierte Logik gekapselt in Services mittels RxJS.
        \lstinline{BehaviorSubject} sendet ersten State bei Aufruf (normales Subject erst beim ersten Change, UI würde leer bleiben).
        Sollte nicht public gemacht werden, ansonsten können Clients \lstinline{next()} aufrufen.

        \begin{lstlisting}
        @Injectable({ providedIn: 'root' })
        export class SampleService {
            private samples: BehaviorSubject<SampleModel[]> = new BehaviorSubject([]); // Event bus which is used to store the last state and to notify subscribers about updates.
            public samples$: Observable<SampleModel[]> = this.samples.asObservable(); // Convert event bus into an observable, which can be provided to the UI or other services.

            constructor(
                private resourceService: SampleResourceService { }
            )

            public addSample(newSample: SampleModel): Observable<any> {
                return this.resourceService
                    .post(newSample)
                    .pipe(
                        tap(res => {
                            this.samples.next([...this.samples.getValue(), newSample]); //  Store the retrieved data into the BehaviorSubject and emit the data changed event. Create a new array, otherwise the pipe cannot track the change.
                        }),
                        catchError((err) => this.handleError(err)));
            }
        }
        \end{lstlisting}

        \textbf{Pipe}: Hilfreich für kleine Transformationen, erlauben Parameter (\lstinline!<p>{{counter.date | date:'longDate'}}</p>!). Pure Pipes werden nur ausgeführt bei Änderungen am Subjekt, impure laufen bei jeder Change Detection.
        Vorgefertige Pipes: \lstinline{async}, \lstinline{number}, \lstinline{date}, \lstinline{percent}.
        Async erlaubt direkte Anzeige ab Observable (\lstinline!<li *ngFor="let s of sampleService.samples$ | async">!)
        Filtering und Ordering Pipes gibt es nicht, gelten als Impure, sollte im Komponent gemacht werden.

        \begin{lstlisting}
        @Pipe({ name: 'logo', pure: true })
        export class LogoPipe implements PipeTransform {
            private logos = { /*...*/ };

            transform(value?: string, transformSettings?: string): string {
                if (value && transformSettings && this.logos[value]) {
                    return (this.logos[value][transformSettings] || this.logos[value]['unspec']);
                }
                return value;
            }
        }
        \end{lstlisting}

        \textbf{Styling}: Styling standardmässig nur auf aktuellen Komponent \lstinline{Emulate}, kann mit \lstinline{encapsulation} kontrolliert werden, \lstinline{Native} verwendet Shadow DOM von Browser, \lstinline{None} fügt alle Styles global zusammen.
        Spezial-Sachen: \lstinline{:host}: Zeigt auf das aktuelle Element.
        \lstinline{host-context}: Sucht Vorgänger ab (\lstinline!:host-context(.theme-light) h2 { }!)
        Drei Wege für Styling: \lstinline{styles}-Array auf Komponent, \lstinline{styleUrls}-Array auf Komponent, zeigt auf (S)CSS-Dateien, \lstinline{template} auf Komponent direkt.

        \textbf{Angular-Tooling}: Angular State Inspector, Redux DevTools, Ahead-Of-Time (AoT) Compilation.

        \section{.NET}
        Weshalb ASP.NET Core: Enterprise Framework, Kompilierbare Sprache (C\#), OS unabhängig.
        \textbf{Attribute}: intensiv eingesetzt (Um Konventionen zu übersteuern bzw zu unterstützen, Schnittstelle für Zusatzinformationen für Framework, Kann via "Reflection" ausgelesen werden).
        \begin{lstlisting}
          [Required]
          [StringLength(100, MinimumLength = 10)]
          public string Name {get; set; }

          [HttpPost]
          public ActionResult About()
        \end{lstlisting}
        % Asseembly.GetEntryassembly().GetTypes(): Findet alle Typen mit einem bestimmten Attribut
        % Activator.CreateInstance(typesWithAttribute.First()): Erzeugt eine Instanz von diesem Type

        \textbf{Extension Methods}: C\# erlaubt es existierenden Klassen Methoden "hinzuzufügen"
        \begin{lstlisting}
          string s = "Hello Extension Methods";
          int i = s.WordCount();

          public static class MyExtensions
          {
            public static int WordCount(this string str) {
              return str.Split(new char[] {' ', '.', '?'}).Length;
            }
          }
        \end{lstlisting}

        \textbf{Async Await}
        \begin{lstlisting}
          static async Task Main(string[] args)
          {
            Console.WriteLine("--");
            await RunAsync();
            Console.WriteLine("--");
            Console.ReadLine();
          }

          public static Task<string> Send()
          {
            return Task.Run(() => {
              Console.WriteLine("Send!");
              return "nachricht gesendet";
            });
          }

          public static async Task<bool> RunAsync()
          {
            Console.WriteLine("Start Send");
            Console.WriteLine(await Send());
            Console.WriteLine("End Send");
            return true;
          }

          % outputs
          % -- start send send! nachricht gesendet end send -- 
        \end{lstlisting}

        \textbf{Convention over configuration (or coding by convention)}: seeks to decreasse the numbere of decision that developers need to make, gaining simplicity, and not necessarily losing flexibility.
        Nachteile: Magie, Ev. Schwer anzupassen (falls Anforderungen nicht ins Schema passen)

        \textbf{Multi-Threading}: Besitzt Thread Pool wo grösse konfigurierbar. Wählt für jeden Request einen Thread aus Pool für bearbeitung.
        Thread solange blockiert bis Request abgeschlossen (oder vorzeitig zurückgegeben: async/await)
        Keine geteilten Daten in Controller / Services halten (z.B. Static Variablen, ASP.NET instanziert für jeden Request neuen Controller)

        \textbf{MVVM} View: Markup Language, was Benutzer sieht, Kommunikation zu ViewModel via Bindings.
        View Model: Daten für View aufbereiten, Value Converter, UI Logik. Model: Daten, Services, Domain Logik.
        Nur Daten an die View ausliefern, die wirklich revelant sind.

        \textbf{Middleware}: Request durchläuft Stack von Middlewares, jede kann Request abbrechen (bsp: autorisierung, MVC, welcomepage..)
        Vier verschiedene Arten Middleware zu registrieren; (neue Middleware registrieren, Verzweigung für Anfragepfad erzeugen, Request Terminieren, CustomMiddleware als Klasse aufrufen)

        \begin{lstlisting}
        # Registiert eine neue Middleware
        app.Use(async (context, next) => {
          await next.Invoke();
        });

        # Erzeugt eine Verzweigung
        app.Map("/logging", builder => {
          builder.Run(async (context) => {
            await context.Response.WriteAsync("Hello There");
          });
        })

        # Terminiert den Request
        app.Run(async (context) => {
          await context.Response.WriteAsync("dead ig");
        });

        # Registierung als Klasse
        app.UseMiddleware<RequestLoggerMiddleware()>;

        public class RequestLoggerMiddleware {
          private readonly RequestDelegate _next;
          private readonly ILogger _logger;
          public RequestLoggerMiddleware(RequestDelegate next, ILoggerFactory loggerFactory) {
            _next = next;
            _logger = loggerFactory.CreateLogger < RequestLoggerMiddleware > ();
          }
          public async Task Invoke(HttpContext context) {
            _logger.LogInformation("Handling request: " + context.Request.Path);
            await _next.Invoke(context);
            _logger.LogInformation("Finished handling request.");
          }
        }
        \end{lstlisting}

        \textbf{Dependency Injection}: Reduziert hohe Kopplung zwischen verschiedenen Klassen, Verbesserung Testbarkeit. ASP.NET kommt mit primitiven Dependency Injection Container.
        Idee: Klasse erwähnt, welche Interfaces benötigt werden, resolver sucht im Container nach Klasse und übergibt. Im Container wurden Interfaces mit konktreten Klassen regiistriert, falls keine vorhannden, Fehler geworfen.

        \begin{lstlisting}
        public class Startup {
          // This method gets called by the runtime. Use this method to add services to the container.
          public void ConfigureServices(IServiceCollection services) {
            services.AddTransient <IUserService, UserService> ();
            //services.AddTransient<IUserService, FakeUserService>();
          }
          // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
          public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) {
            app.UseMiddleware < UserMiddleware > ();
          }
        }
        \end{lstlisting}

        DI - Lifetime: Transient: created each time they are requested. Best for lightweeight, stateless services. Scoped: created once per request. Singleton: created the first time they are requested and then every subsequent request will use the same instance.
        \textbf{Captive Dependency}: Wenn Singleton Scoped Service verwendet, wird Scope Service nur einmal erzeugt, kann Probleme verursachen.

        \textbf{Projekt-Struktur}
        wwwroot: statischen Inhalte der Webseite z.B. CSS/JS/HTML, keine sensitiven Daten
        appsettings.json: Einstellungen der Webseite z.B. Connection-String zur DB
        Programm.cs: Einstiegspunkt von der Web Applikation
        Startup.cs: Konfiguriert die Web Applikation.

        Nur nötige Endpoints und Services registrieren.

        \begin{lstlisting}
        builder.Services.AddControllers();
        builder.Services.AddRazorPages();
        builder.Services.AddControllersWithViews();
        builder.Services.AddMvc();
        \end{lstlisting}

        \textbf{Pages}: Geeignte für Web Applikationen mit "Page" Fokus (Alternative und vereinfachte Variante vom MVC, Router muss nicht konfiguriert werden, Best-Practices for SSR)
        Routing: generiert anhand von URL Antwort, URL wird auf Aktion: "gemappt" (Routing-Module). Bei Aufruf im Folder "/pages/" nach Page gesucht und ausgeführt (default case insensitive)
        MVVM: Besteht aus 2 Files, *.cshtml (View mit Razor), *.cshtml.cs (Viewmodel)
        \begin{lstlisting}
        @page
        @model PostModel
        @{
            ViewData["Title"] = "Post";
        }

        <form asp-page="Post">
            <input name="echoText" placeholder="Echo-Text" />
            <input name="times" type="number" placeholder="Anzahl" />
            <button type="submit">Send</button>
        </form>

        @if (Model.Times > 0)
        {
            for (var i = 0; i < Model.Times; i++)
            {
                <span>@Model.EchoText</span>
            }
        }

        public class PostModel : PageModel
        {
            public string EchoText { get; set; }
            public long Times { get; set; }
            public void OnGet()
            {

            }   

            public void OnPost(string echoText, long times)
            {
                EchoText = echoText;
                Times = times;            
            }
        }


        public class PostModel2 : PageModel
        {
            [BindProperty]
            public string EchoText { get; set; }

            [BindProperty]
            public long Times { get; set; }
        }
        \end{lstlisting}
        \lstinline{@model}: Beschreibt Type vom View Model dieser Seite, wird in Var Model abgelegt
        PageModel: Basis-Klasse mit Hilfsfunktionen (Redirects / Event-Hooks), Aufbereitung der Daten für die View
        MVVM - Model: kann pro HTTP-Verb eine Funktion definieren die davor aufgerufen wird (\lstinline{OnGet}, \lstinline{OnPost}), Body und Query werden automatisch gemappt, Parameter werden als Argumente übergeben, können auch als Klasse entgegen genommen werden.
        Mit [BindProperty] kann auf das Kopieren von Properties verzichtet werden, nutzen falls Properties 1:1 der View übergeben werden \lstinline{[BindProperty(SupportsGet = true)]}
        View: @page definiert Razor-File als Page, @page "/test/{id?}" überschreibt Default-Routing Informationen
        kann auf verschiedene Arten zugegriffen werden:
        \begin{lstlisting}
          @page "/test/{id:int?}"
          @model Ex.Pages.Page.RoutingModel
          @{
            ViewData["Title"] = "Routing";
          }
          <h1>Routing</h1>
          @RouteData.Values["id"]

          public class RoutingModel : PageModel
          {
            public int Id {get;set;}
            [BindProperty(SupportsGet = true, Name="Id")]

            public int Id2 {get;set;}
            public void OnGet(int id)
            {
              Id2=id
            }
          }
        \end{lstlisting}

        \textbf{Razor}: Wichtige Dateien: Layout: Shared/\_layout.cshtml: definiert generelle Layout für Applikation, definiert Sections, welche von Content Page abgefüllt werden.
        Beinhaltet Struktur der Webseite, welche für jede Seite identisch sein sollte.

        \begin{lstlisting}
        <div class="container">
            @RenderBody()
        </div>

        <div class="container">
            <a class="navbar-brand" asp-area="" asp-page="/Index">Home</a> @RenderSection("Nav", false)
        </div>

        @section Nav{
            <a class="navbar-brand" asp-area="" asp-page="./ViewData">ViewData</a> <a class="navbar-brand" asp-area="" asp-page="./TempData">TempData</a>
        }
        \end{lstlisting}

        \_ViewStart.cshtml: Hierarchisch, beinhaltet Codee welcher vor den Razor Files ausgeführt wird z.B. Layout für alle Pages
        \_ViewImports.cshtml: Hierarchisch, Namespaces \& Tag-Helpers können in diesem File registriert werden

        \textbf{Tag Helpers}: Ermöglichen Code an HTML Tags zu binden
        \begin{lstlisting}
          <email mail-for="support@examl.com"></email>
          <a href="mailto:support@example.com">support@example.com</a>

          public classs EmailTagHelper : TagHelper 
          {
            public string MailFor {get;set;}
            public override void Process(TagHelperContext context, TagHelperOutput ouput)
            {
              output.TagName = "a";
              output.Attributes.SetAttrbutes("href", "mailto:" + MailFor);
              output.Content.SetContent(MailFor);
            }
          }

        # dann im ViewImports.cshtml
        @addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
        @addTagHelper *, DataBinding
        \end{lstlisting}

        Daten zwischen Razor-Dateien: Daten im View Model übergeben, stehen nur in der zugehörigen View zur Verfügung.
        Können als ViewData oder TempData gekennzeichnet werden (mit \lstinline{[TempData]} oder \lstinline{[ViewData]} auf Property).
        TempData (überlebt einen Redirect)

        \textbf{AJAX}
        Handlers: Pages können weiter Actions als "handler" anbieten; Schema; On[Method][Name] z.B. OnPostEcho, aufgerufen via: [METHOD] /[PAGE]?handler=[HandlerName]: GET /Ajax?handler=autocomplete
        Erlaubte Rückgabewerte sind vom Type IActionResult (Bsp; ContentResult: JsonResult, Status: NotFoundResult, Redirects: RedirectToPage)

        \begin{lstlisting}
        @page
        @{
            ViewData["Title"] = "AjaxAutocomplete";
        }

        <input id="city" list="cities-list" />
        <datalist id="cities-list"></datalist>

        @section Scripts{
            <script>
                const list = document.getElementById("cities-list");

                document.getElementById("city").addEventListener("input",
                    async (args) => {
                        var url = new URL("./Ajax/Ajax", window.location.origin);
                        var params = { handler: "Autocomplete", text: args.target.value }
                        url.search = new URLSearchParams(params);

                        const result = await fetch(url, { method: "get" });
                        list.innerHTML = (await result.json()).map(x => `<option>${x}</option>`);
                    });
            </script>
        }

        public class AjaxModel : PageModel
        {
            private readonly CitiesService _citiesService;

            public AjaxModel(CitiesService citiesService)
            {
                _citiesService = citiesService;
            }
            public void OnGet()
            {
                throw new NotSupportedException();
            }

            public IActionResult OnGetAutocomplete(string text)
            {
                return new JsonResult(_citiesService.GetCities(text));
            }
        }
        \end{lstlisting}

        \textbf{Entity Framework (EF)}: objektrelationale Zuordung, die Entwickler über domänenspezifsche Objekte die Nutzung relationaler Daten ermöglicht. (wenig Code, viele Konvention, OR-Mapper). SQL-Rows auf Klasse mappen, Relationen auflöseen und richtig setzen.
        Code First benötigt; type discovery: welche Klassen gehören in die DB, Connection String: Wohin mit Daten, DbContext: Entry Point
        Konfiguration im \lstinline{Startup.cs}, Connection String dann im \lstinline{appsettings.json}.

        \begin{lstlisting}
          public class Order
          {
            public long Id {get;set;}
            [Required]
            public string Name {get;set;}
            public DateTime Date {get;set;}
            public virtual ApplicationUser Customer {get;set;}
            public Order() {
              Date = DateTime.Now;
            }
          }
        \end{lstlisting}

        \lstinline{public [long/string] Id}: automatisch Primary key von Entity
        \lstinline{public virtual ApplicationUser Customer}: automatisch als Navigation Property erkannt (CustomerId: wird als Foreign Key für Customer Property erkannt)
        \lstinline{[Required]}: NotNull, \lstinline{[NotMapped]}: nicht in DB geschrieben, \lstinline{[Key]}: Definiert Primary Key der Entity, \lstinline{[MaxLength(10)]}: Beeinflusst die Grösse des Feldes in DB

        % migrations explizit ausgelassen, kann aber hinzugefügt werden falls nötig..
        \textbf{Validation}: Client: JQuery Validation, Server: ASPNET, z.B. Annotieren der Klasse z.B. [Required] oder [StringLength(60, MinimumLength=3)] (Sind kombinierbar), Razor anpassen (Validation ins DOM einfügen), Server Side validierung

        \begin{lstlisting}
        [HttpPost]
        public ActionResult Index(Order order) {
            if (ModelState.IsValid)
            {
                order.CustomerId = User.Identity.GetUserId();
                _db.Orders.Add(order);
                _db.SaveChanges();
                return View("OrderOk", order);
            }
            return BadRequest();
        }
        \end{lstlisting}

        \textbf{ASPNET identity features}: nimmt probleme wie user validation oder passwort stärke ab (gibt Identity Klassen die via DI injected werden können z.B. UserManager oder RoleManager).
        Aktivierung mit Middle \lstinline{app.UseIdentity();}.

        \begin{lstlisting}
        services.AddDefaultIdentity<IdentityUser> (options => {
            options.Password.RequireDigit = false;
            options.Password.RequireLowercase = false;
            options.Password.RequireNonAlphanumeric = false;
            options.Password.RequiredLength = 4;
          })
          .AddRoles < IdentityRole > ().AddEntityFrameworkStores < ApplicationDbContext > ();
        \end{lstlisting}

        \lstinline{[Authorize]}: User muss authentifiziert sein (kann auf Controller/Pages definiert werden), \lstinline{[AllowAnonymous]}: erlaubt für spezifische Action anonymen Zugriff

        \lstinline{this.User} (Controller/Pages): Beinhaltet den eingeloggten User, Type is ClaimsPrincipal (Applicationuser)
        Claim: Statement über User, vom Identity Provider ausgestellt
        Manuell authentifizierbar via \lstinline{User.Identity.isAuthenticated}
        Autorisierung: via Attribute \lstinline{[Authorize(Roles="Admin, PowerUser")]} oder \lstinline{[Authorize(Policy="OlderThan18")]} oder via Services z.B. \lstinline{await userManager.isInRoleAsync(user, "Admin")}.
        Policies ermöglichen, komplexere Regeln zu definieren.

        \begin{lstlisting}
          options.AddPolicy("Founders", policy => {
            policy.RequireClaim(ClaimTypes.Name, "foo.bar@ost.ch");
          });
        \end{lstlisting}

        \textbf{Unit testing}: Verschiedene Frameworks, xunit in diesem Kurs.
        \lstinline{[Fact]}-Attribut kennzeichnet eine Test-Methode.

        \begin{lstlisting}
        [Fact]
        public async void CreateFailing() {
          AddModel model = new AddModel(null);
          model.Order = new NewOrderViewModel();
          ValidateModel(model.Order, model);
          Assert.NotNull(await model.OnPostAsync());
        }
        private static void ValidateModel(object model, AddModel page) {
          var context = new ValidationContext(model);
          var validationResults = new List < ValidationResult > ();
          Validator.TryValidateObject(model, context, validationResults, true);
          foreach(var validationResult in validationResults) {
            page.ModelState.AddModelError("CustomError", validationResult.ErrorMessage);
          }
        }
        \end{lstlisting}

        \textbf{API Routing}: Funktioniert über Attribute [Route] definieret einen neuen Eintag im Router, [HttpMethod] bei Actions ist required
        \lstinline{[Route("api/[controller]")]}: Klassen def: [HttpGet] public IEnumerable<Value> Get()  oder [HttpGet("{id}")] public Value Get(int id)

        \begin{lstlisting}
        [Route("api/[controller]")]
        public class ValuesController: Controller {
          [HttpGet]
          public IEnumerable < Value > Get() {
              return _valueService.All();
            }
            [HttpGet("{id}")]
            public Value Get(int id) {
              return _valueService.Get(id);;
            }
            [HttpPost]
            public void Post([FromBody] Value value) {
              _valueService.Add(value);
            }
            ...
        }
        \end{lstlisting}
        % swagger configuration scheint auch nicht relevant / brauchbar zu sein

        \textbf{REST Hateoas}: Idee: Verlinkte Daten als Links zur Verfügung stellen 
        % again here, wirkt mir ein zu spezifisch und zu viel Boilerplate das es relevant ist

        \textbf{Exception Handling}: Error Handling soll generisch funktionieren: Gibt Exception, welche die notwendige Daten sammelt, globalen Errorhandler, welche Exception für Client aufbereitet, bei ungültigen Zustand wird Custom Exception ausgelöst.
        ASP.NET MVC erlaubt es Filter zu definieren, welche für jede Action aufgerufen werden 
        \begin{lstlisting}
          services.AddMvc(options => {
            options.Filters.Add(new ValidationModelAttribute());
          }));

          public class ValidateModelAttribute:ActionFilterAttribute{
            public override void OnActionExecuting(ActionExecutingContext context) {
              if (!context.ModelStatee.IsValid) throw new ServicExceptionType.ForbiddenByRule);}
            }
          }
        \end{lstlisting}
        
        % what JWT is and what it does we know, doesn't seem to make sense to add it... same for the info "ony send tokenss via Https"
        % and that it can be activated via app.useHttpsRedirection()
      
        % integration tests also seem "irrelevant" but nice to know ig...

        \section{PWA}

        \textbf{Firebase}: Tools von Google zur Realisierung einer PWA (aja Hr. Gfeller).
        \textbf{Firestore}: No-SQL Datenbank, Kollektionen beinhalten Dokumente beinhalten beliebige Felder.
        \textbf{Angularfire}: Wrapper für Firebase SDK, bietet Dependency injection, Observable based, Router Guards.
        \textbf{Cypress}: E2E testing, gibt für Angular ein Schematic-Paket, bei React muss manuell verhängt werden.

        Progressive Web App selber: Web-Applikation, die sich anfühlt wie eine native Applikation.
        Investition lohnt sich, anscheinend gute Conversion Rate.
        Alternative: Native Applikation, lohnt sich eventuell nicht, da Nutzer nicht viel zwischen Apps hin- und herspringen.

        Eigenschaften PWA: \textbf{Safe}: Muss über HTTPS ausgeliefert werden.
        \textbf{Responsive}: Das UI soll für alle Grössen passen.
        \textbf{Progressive}: Die neuen API’s nutzen, um die bestmögliche UX zu erreichen, ohne die älteren Browser zu ignorieren.
        \textbf{Linkable}: Teilen von Inhalten ohne das der Sharing-Partner eine App installieren muss.
        \textbf{Discoverable}: Die Webseite soll über Suchmaschinen auffindbar sein.
        \textbf{Installable}: Die Web Applikation mit Icon auf den Startbildschirm speichern (Web App Manifest).
        \textbf{Network independent}: Die App soll auch mit schlechter, langsamer oder sogar gar keiner Verbindung funktionieren.
        \textbf{Re-engageable}: Es soll möglich sein das die Verbindung zum Benutzer der Seite wieder aufgenommen werden, obwohl der Benutzer die Seite nicht geöffnet hat (Service Workers, Push-API).

        PWA-Installation kann mittels JavaScript gemacht werden.

        Im Manifest kann angegeben werden, dass PWA in einem Standalone-Fenster gestartet wird.
        Nachteil, browserspezifische Features gehen verloren (wie z.B. Zurück-Button).
        Feature muss nachgebaut werden, Anzeige kann mittels CSS-Media-Query \lstinline{display-mode} gesteuert werden (\lstinline{fullscreen} (Kiosk-Mode), \lstinline{standalone}, \lstinline{minimal-ui} (bietet minimale Navigationsfeatures), \lstinline{browser}).
    \end{multicols}
\end{document}
